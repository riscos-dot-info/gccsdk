112a113
> static int arm_leaf_function_p (void);
151a153,154
> static void arm_aof_asm_named_section (const char *, unsigned int);
> static void arm_aof_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED);
587a591,616
> #ifdef TARGET_TUNE_DEFAULT
>       /* If the user didn't specify tuning either, use the target's
> 	 preferred flags.  */
>       if (tune_flags == 0)
> 	{
> 	  const struct processors * tunesel;
> 	  const struct cpu_default * tunedef;
> 
> 	  for (tunedef = cpu_defaults; tunedef->name; tunedef++)
> 	    if (tunedef->cpu == TARGET_TUNE_DEFAULT)
> 	      break;
> 
> 	  if (tunedef->name == NULL)
> 	    abort ();
> 
> 	  for (tunesel = all_cores; tunesel->name != NULL; tunesel++)
> 	    if (streq (tunedef->name, tunesel->name))
> 	      break;
> 
> 	  if (tunesel->name == NULL)
> 	    abort ();
> 
> 	  tune_flags = tunesel->flags;
> 	}
> #endif
> 
670c699
< 	 "-mapcs-32 -mcpu=arm2" then we loose here.  */
---
> 	 "-mapcs-32 -mcpu=arm2" then we lose here.  */
752a782,790
>   /* RISC OS RMA module support.  */
>   if (TARGET_MODULE)
>     {
>       flag_pic = 1;
>       /* We use r8 as the PIC register as r9 is reserved for the frame
> 	 pointer and r10 is the stack-limit register.  */
>       arm_pic_register = 8;
>     }
> 
1033c1071
<   if (IS_INTERRUPT (func_type) && frame_pointer_needed)
---
>   if (IS_INTERRUPT (func_type) && arm_apcs_frame_needed ())
1043,1044c1081,1083
<       /* Or if the function calls alloca */
<       || current_function_calls_alloca
---
>       /* NAB++ */
>       || (current_function_calls_alloca && ! TARGET_APCS_FRAME)
>       /* NAB-- */
1047c1086,1087
<       || !(stack_adjust == 0 || (frame_pointer_needed && stack_adjust == 4)))
---
>       || !(stack_adjust == 0 ||
> 	   (arm_apcs_frame_needed () && stack_adjust == 4)))
2488,2489c2528,2530
<      are in Thumb mode.  */
<   if (decl == NULL || TARGET_THUMB)
---
>      are in Thumb mode.  With explicit stack checking, tail calls
>      result in undefined behaviour.  */
>   if (decl == NULL || TARGET_THUMB || TARGET_APCS_STACK) /* NAB */
2561a2603,2622
>       if (TARGET_MODULE)
> 	{
> 	  tree ftree;
> 	  /* printf ("legitimize_pic: sym=%s, local=%d, constp=%d\n",
> 		  XSTR (orig, 0),
> 		  SYMBOL_REF_LOCAL_P (orig),
> 		  TREE_CONSTANT_POOL_ADDRESS_P (orig));*/
> 
> 	  insn = emit_insn (gen_pic_load_addr_arm (reg, orig));
> 	  /* Don't do reallocation based on PIC register when our
> 	     symbol is a function, i.e. do this only for global/local
> 	     variables.  */
> 	  /* FIXME: this requires more attention : in case ftree is NULL
> 	     it is not clear what should be done with symbols generated
> 	     by the compiler itself and not coming from src code.  */
> 	  ftree = SYMBOL_REF_DECL(orig);
> 	  if (ftree != NULL && TREE_CODE(ftree) != FUNCTION_DECL)
> 	    insn = emit_insn (gen_addsi3 (reg, reg, pic_offset_table_rtx));
> 	}
>       else
2659,2660c2720,2747
< #ifndef AOF_ASSEMBLER
<   rtx l1, pic_tmp, pic_tmp2, seq, pic_rtx;
---
> #ifdef AOF_ASSEMBLER
>   rtx seq;
>   rtx sb_reg, sl_reg, sb_ref;
>   int static_data_offset;
> 
>   if (current_function_uses_pic_offset_table == 0 || TARGET_SINGLE_PIC_BASE)
>     return;
> 
>   if (!flag_pic)
>     abort ();
> 
>   start_sequence ();
> 
>   if (TARGET_LIBSTATICS)
>     static_data_offset = -540;
>   else
>     static_data_offset = -536;
> 
>   sl_reg = gen_rtx_REG (Pmode, SL_REGNUM);
>   sb_ref = gen_rtx_MEM (Pmode,
> 			gen_rtx_PLUS (Pmode,
> 				      sl_reg, GEN_INT (static_data_offset)));
>   RTX_UNCHANGING_P (sb_ref) = 1;
>   emit_insn (gen_rtx_SET (SImode, pic_offset_table_rtx, sb_ref));
> 
> #else /* ! AOF_ASSEMBLER */
>   rtx seq;
>   rtx l1, pic_tmp, pic_tmp2, pic_rtx;
2669a2757
> 
2693a2782
> #endif /* AOF_ASSEMBLER */
2705d2793
< #endif /* AOF_ASSEMBLER */
6887,6888c6975,6976
<   if (flag_pic && GET_CODE (value) == SYMBOL_REF)
<     value = aof_pic_entry (value);
---
>   if (flag_pic && GET_CODE (value) == SYMBOL_REF && ! TARGET_MODULE)
>     value = aof_pic_entry (value, 0);
6904c6992
<   if (fix->forwards == 0 && fix->backwards == 0)
---
>   if (fix->forwards == 0 && fix->backwards == 0 /*&& !TARGET_MODULE*/)
7298a7387
> 
8049c8138
< /* Compute the register sabe mask for registers 0 through 12
---
> /* Compute the register save mask for registers 0 through 12
8093,8096c8182,8185
< 	  && ! frame_pointer_needed
< 	  && regs_ever_live[HARD_FRAME_POINTER_REGNUM]
< 	  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])
< 	save_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;
---
> 	  && ! arm_apcs_frame_needed ()
> 	  && regs_ever_live[ARM_HARD_FRAME_POINTER_REGNUM]
> 	  && ! call_used_regs[ARM_HARD_FRAME_POINTER_REGNUM])
> 	save_reg_mask |= 1 << ARM_HARD_FRAME_POINTER_REGNUM;
8124c8213
<   if (frame_pointer_needed)
---
>   if (arm_apcs_frame_needed ())
8253c8342
< 	  if (frame_pointer_needed)
---
> 	  if (arm_apcs_frame_needed ())
8288a8378,8385
> #ifdef TARGET_RISCOSAOF
>           if (arm_apcs_frame_needed ())
>             sprintf (instr, "ldm%sea\t%%|fp, {", conditional);
>           else if (live_regs_mask & (1 << SP_REGNUM))
>             sprintf (instr, "ldm%sfd\t%%|sp, {", conditional);
>           else
>             sprintf (instr, "ldm%sfd\t%%|sp!, {", conditional);
> #else
8291c8388
< 	     frame_pointer_needed is true, but only if sp already
---
> 	     arm_apcs_frame_needed () is true, but only if sp already
8308a8406
> 
8313a8412
> #endif
8498c8597
<   asm_fprintf (f, "\t%@ args = %d, pretend = %d, frame = %wd\n",
---
>   asm_fprintf (f, "\t%@ args = %d, pretend = %d, frame = %wd, alloca = %d\n",
8500c8599,8600
< 	       current_function_pretend_args_size, frame_size);
---
> 	       current_function_pretend_args_size, frame_size,
> 	       current_function_calls_alloca);
8503c8603
< 	       frame_pointer_needed,
---
> 	       arm_apcs_frame_needed (),
8505a8606,8613
>   asm_fprintf (f, "\t%@ nonlocal_label = %d, nonlocal_goto = %d, leaf = %d\n",
>                current_function_has_nonlocal_label,
>                current_function_has_nonlocal_goto,
>                arm_leaf_function_p ());
> 
>   asm_fprintf (f, "\t%@ outgoing_args = %d, pops_args = %d\n",
> 	       cfun->outgoing_args_size, cfun->pops_args);
> 
8510c8618
<   if (flag_pic)
---
>   if (flag_pic && ! TARGET_MODULE)
8575c8683
<   if (frame_pointer_needed)
---
>   if (arm_apcs_frame_needed ())
8663a8772,8774
> #ifdef TARGET_RISCOSAOF
>       print_multi_reg (f, "ldmea\t%r", FP_REGNUM, saved_regs_mask);
> #else
8678a8790
> #endif
8811c8923
<       if (frame_pointer_needed)
---
>       if (arm_apcs_frame_needed ())
8850,8851c8962,8963
< 	  && (frame_size + current_function_outgoing_args_size) != 0
< 	  && !frame_pointer_needed)
---
> /* NAB */ && abs (frame_size + current_function_outgoing_args_size) > 256
> 	  && !arm_apcs_frame_needed ())
9036a9149,9191
> /* NAB++ */
> /* Given FROM and TO register numbers, say whether this elimination is
>    allowed.  Frame pointer elimination is automatically handled.  */
> int
> arm_can_eliminate (from, to)
>      int from, to;
> {
> #ifdef TARGET_RISCOSAOF
>   /* We can eliminate ARGP to STACKP if no alloca, no stack checks needed
>      and frame not needed.  */
>   if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM
>       && ! arm_apcs_frame_needed ())
>     return 1;
> 
>   /* FRAMEP can be eliminated to STACKP.  */
>   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
>     return 1;
> 
>   /* Can't do any other eliminations.  */
>   return 0;
> #else
>   /*  All eliminations are permissible.  Note that ARG_POINTER_REGNUM and
>       HARD_FRAME_POINTER_REGNUM are in fact the same thing.  If we need a frame
>       pointer, we must eliminate FRAME_POINTER_REGNUM into
>       HARD_FRAME_POINTER_REGNUM and not into STACK_POINTER_REGNUM or
>       ARG_POINTER_REGNUM.  */
>   if (to == FRAME_POINTER_REGNUM && from == ARG_POINTER_REGNUM)
>     return 0;
> 
>   if (to == STACK_POINTER_REGNUM && arm_apcs_frame_needed ())
>     return 0;
> 
>   if (to == ARM_HARD_FRAME_POINTER_REGNUM && TARGET_THUMB)
>     return 0;
> 
>   if (to == THUMB_HARD_FRAME_POINTER_REGNUM && TARGET_ARM)
>     return 0;
> 
>   return 1;
> #endif
> }
> /* NAB-- */
> 
9111c9266
<       if (frame_pointer_needed)
---
>       if (arm_apcs_frame_needed ())
9132c9287
<   stack_frame = frame_pointer_needed ? 16 : 0;
---
>   stack_frame = arm_apcs_frame_needed () ? 16 : 0;
9133a9289,9303
> #ifdef TARGET_RISCOSAOF
>   if (from == ARG_POINTER_REGNUM || to == ARG_POINTER_REGNUM)
>     {
>       /* printf ("eliminate offset: local = %d, outgoing = %d, call_saved = %d, stack_frame = %d, total = %d\n",
> 	      local_vars, outgoing_args, call_saved_registers, stack_frame,
> 	      local_vars + outgoing_args + call_saved_registers + stack_frame - 4); */
>       return (local_vars + outgoing_args + call_saved_registers
> 	      + stack_frame - 4);
>     }
> 
>   if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)
>     return 0;
> 
>   abort ();
> #else
9159c9329
< 	  return (frame_pointer_needed
---
> 	  return (arm_apcs_frame_needed ()
9203a9374,9385
> #endif /* ! TARGET_RISCOSAOF */
> }
> 
> /* NAB++ */
> /* Return non-zero if this is a leaf function.  */
> static int
> arm_leaf_function_p (void)
> {
>   if (cfun->machine->leaf < 0)
>     cfun->machine->leaf = leaf_function_p ();
> 
>   return cfun->machine->leaf;
9205a9388,9436
> /* Return 1 if the function prologue should contain an explicit
>    stack check.  */
> static int
> arm_stack_check_needed (void)
> {
>   /* Don't do any stack checking if it was not asked for.  */
>   if (! TARGET_APCS_STACK)
>     return 0;
> 
>   /* We will always use stack checking for non-optimising
>      circumstances.  */
>   if (! optimize)
>     return 1;
> 
>   /* Don't do any stack checking if the function is a leaf function
>      and the amount of stack actually needed <= 256 bytes.  */
>   if (arm_leaf_function_p () && abs (cfun->machine->frame_size) <= 256)
>     return 0;
> 
>   return 1;
> }
> 
> /* Return 1 if the function prologue really needs to setup an APCS
>    frame.  */
> int
> arm_apcs_frame_needed ()
> {
>   /* If we are not targeting the APCS, we will not use a stack frame.  */
>   if (! TARGET_APCS_FRAME)
>     return 0;
> 
>   /* If we are not optimising, or we call alloca, we will always
>      setup a frame.  */
>   if (current_function_calls_alloca
>       || current_function_has_nonlocal_goto
>       || current_function_has_nonlocal_label
>       || ! optimize)
>     return 1;
> 
>   /* A frame will need to be setup for the cases where there are external
>      function calls within the current function or there is a need
>      for definite stack checking.  */
>   if (! arm_leaf_function_p () || arm_stack_check_needed ())
>     return 1;
> 
>   return 0;
> }
> /* NAB-- */
> 
9239c9470
<   leaf = leaf_function_p ();
---
>   leaf = arm_leaf_function_p (); /* NAB++ */
9290c9521
<   int reg;
---
>   int reg, frame_size;
9314c9545
<   if (frame_pointer_needed)
---
>   if (arm_apcs_frame_needed ())
9434c9665
<       && ! frame_pointer_needed)
---
>       && ! arm_apcs_frame_needed ())
9508,9509c9739,9748
<   if (frame_pointer_needed)
<     {
---
>   /* NAB++ */
>   frame_size = -(arm_get_frame_size ()
>                  + current_function_outgoing_args_size);
>   /* NAB-- */
>   if (arm_apcs_frame_needed ())
>     {
>       /* NAB++ */
>       rtx fp_rtx = gen_rtx_REG (SImode, FP_REGNUM);
>       /* NAB -- */
> 
9512c9751
<       insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));
---
>       insn = emit_insn (gen_addsi3 (fp_rtx, ip_rtx, insn)); /* NAB++ */
9514a9754,9790
> #ifdef TARGET_RISCOSAOF
>       emit_insn (gen_blockage ());
>       /* Explicit stack checks.  */
>       if (TARGET_APCS_STACK)
>         {
> 	  rtx sl_reg = gen_rtx_REG (GET_MODE (stack_pointer_rtx), 10);
>           if (frame_size <= -256)
>             {
>               rtx stkovf = gen_rtx_SYMBOL_REF (Pmode, ARM_STKOVF_SPLIT_BIG);
>               rtx last = get_last_insn ();
>               insn = emit_insn (gen_addsi3 (ip_rtx, stack_pointer_rtx,
>                                             GEN_INT (frame_size)));
>               do
>               {
>                 last = last ? NEXT_INSN (last) : get_insns ();
>                 RTX_FRAME_RELATED_P (last) = 1;
>               }
>               while (last != insn);
>               insn = emit_insn (gen_prologue_use (ip_rtx));
>               RTX_FRAME_RELATED_P (insn) = 1;
>               insn = emit_insn (gen_rt_stkovf (ip_rtx, sl_reg, stkovf));
>               RTX_FRAME_RELATED_P (insn) = 1;
>               /* Create barrier to prevent real stack adjustment from being
>                  scheduled before call to stack checker.  */
>               emit_insn (gen_blockage ());
>             }
>           else
>             {
>               rtx stkovf = gen_rtx_SYMBOL_REF (Pmode, ARM_STKOVF_SPLIT_SMALL);
> 
>               insn = emit_insn (gen_rt_stkovf (stack_pointer_rtx,
>                                                sl_reg, stkovf));
>             }
>           RTX_FRAME_RELATED_P (insn) = 1;
>         }
> #endif
> 
9522a9799,9802
> #ifdef TARGET_RISCOSAOF
> 	      insn = gen_rtx_PLUS (SImode, fp_rtx,
> 				   GEN_INT (4));
> #else
9524a9805
> #endif
9534,9535d9814
<   amount = GEN_INT (-(arm_get_frame_size ()
< 		      + current_function_outgoing_args_size));
9537c9816
<   if (amount != const0_rtx)
---
>   if (frame_size != 0) /* NAB++ */
9543c9822
< 				    amount));
---
> 				    GEN_INT (frame_size)));
9554c9833
<       if (frame_pointer_needed)
---
>       if (arm_apcs_frame_needed ())
9556a9836,9846
> 
>       /* NAB++ */
> #ifdef TARGET_RISCOSAOF
>       if (cfun->machine->apply_args || ! optimize)
>         {
>           insn = emit_insn (gen_movsi (frame_pointer_rtx,
>                                        stack_pointer_rtx));
>           RTX_FRAME_RELATED_P (insn) = 1;
>         }
> #endif
>       /* NAB-- */
10516c10806
<   if ((TARGET_THUMB || !frame_pointer_needed)
---
>   if ((TARGET_THUMB || !arm_apcs_frame_needed ())
12089a12380,12381
>   machine->leaf = -1; /* NAB */
>   machine->apply_args = 0;
12227c12519
<   if (frame_pointer_needed)
---
>   if (arm_apcs_frame_needed ())
12264c12556
< 		&& !(frame_pointer_needed
---
> 		&& !(arm_apcs_frame_needed ()
12337c12629
<   if (frame_pointer_needed)
---
>   if (arm_apcs_frame_needed ())
12933a13226,13232
> /* NAB++ */
> #ifdef AOF_ASSEMBLER
>   if (name[0] != '|')
>     fputc ('|', stream);
> #endif
> /* NAB-- */
> 
12937a13237,13243
> 
> /* NAB++ */
> #ifdef AOF_ASSEMBLER
>   if (name[0] != '|')
>     fputc ('|', stream);
> #endif
> /* NAB-- */
12952a13259,13260
> /* If type == 0, then return an offset against x$adcons, otherwise
>    just supply an RTX const.  */
12954c13262
< aof_pic_entry (rtx x)
---
> aof_pic_entry (rtx x, int type)
12966a13275,13276
>       {
> 	if (type == 0)
12967a13278,13279
> 	return GEN_INT (offset);
>       }
12971a13284
>   if (type == 0)
12972a13286
>   return GEN_INT (offset);
12982a13297,13299
>   if (TARGET_MODULE)
>     asm_fprintf (f, "\tAREA |%r$$adcons|\n", PIC_OFFSET_TABLE_REGNUM);
>   else
13004c13321
<   if (flag_pic)
---
>   if (flag_pic && !TARGET_MODULE)
13018a13336,13359
> /* NAB ++ */
> static int arm_rodata_section_count = 1;
> 
> char *
> aof_rodata_section ()
> {
>   static char buf[100];
>   sprintf (buf, "\tAREA |C$$rodata%d|, DATA, READONLY",
>            arm_rodata_section_count++);
>   return buf;
> }
> 
> static int arm_bss_section_count = 1;
> 
> char *
> aof_bss_section ()
> {
>   static char buf[100];
>   sprintf (buf, "\tAREA |C$$bss%d|, DATA, NOINIT",
>            arm_data_section_count++);
>   return buf;
> }
> /* NAB -- */
> 
13078,13079c13419,13420
<       fputs ("\tIMPORT __main\n", f);
<       fputs ("\tDCD __main\n", f);
---
>       fputs ("\tIMPORT\t|__main|\n", f);
>       fputs ("\tDCD\t|__main|\n", f);
13103,13127c13444,13445
<   fputs ("__r0\tRN\t0\n", asm_out_file);
<   fputs ("__a1\tRN\t0\n", asm_out_file);
<   fputs ("__a2\tRN\t1\n", asm_out_file);
<   fputs ("__a3\tRN\t2\n", asm_out_file);
<   fputs ("__a4\tRN\t3\n", asm_out_file);
<   fputs ("__v1\tRN\t4\n", asm_out_file);
<   fputs ("__v2\tRN\t5\n", asm_out_file);
<   fputs ("__v3\tRN\t6\n", asm_out_file);
<   fputs ("__v4\tRN\t7\n", asm_out_file);
<   fputs ("__v5\tRN\t8\n", asm_out_file);
<   fputs ("__v6\tRN\t9\n", asm_out_file);
<   fputs ("__sl\tRN\t10\n", asm_out_file);
<   fputs ("__fp\tRN\t11\n", asm_out_file);
<   fputs ("__ip\tRN\t12\n", asm_out_file);
<   fputs ("__sp\tRN\t13\n", asm_out_file);
<   fputs ("__lr\tRN\t14\n", asm_out_file);
<   fputs ("__pc\tRN\t15\n", asm_out_file);
<   fputs ("__f0\tFN\t0\n", asm_out_file);
<   fputs ("__f1\tFN\t1\n", asm_out_file);
<   fputs ("__f2\tFN\t2\n", asm_out_file);
<   fputs ("__f3\tFN\t3\n", asm_out_file);
<   fputs ("__f4\tFN\t4\n", asm_out_file);
<   fputs ("__f5\tFN\t5\n", asm_out_file);
<   fputs ("__f6\tFN\t6\n", asm_out_file);
<   fputs ("__f7\tFN\t7\n", asm_out_file);
---
>   fprintf (asm_out_file, "%s Generated by gcc %s for ARM/%s\n",
> 	   ASM_COMMENT_START, version_string, ARM_OS_NAME);
13138a13457,13507
> 
> /* Switch to an arbitrary section NAME with attributes as specified
>    by FLAGS.  ALIGN specifies any known alignment requirements for
>    the section; 0 if the default should be used.
> 
>    Differs from the default elf version only in the prefix character
>    used before the section type.  */
> 
> static void
> arm_aof_asm_named_section (const char *name, unsigned int flags)
> {
>   char flagchars[10], *f = flagchars;
> 
>   fprintf (asm_out_file, "\tAREA\t|C$$%s|", name);
> 
>   if (flags & SECTION_DEBUG)
>     fprintf (asm_out_file, ", DEBUG");
>   if (!(flags & SECTION_WRITE))
>     fprintf (asm_out_file, ", READONLY");
>   if (flags & SECTION_CODE)
>     fprintf (asm_out_file, ", CODE");
>   else
>     fprintf (asm_out_file, ", DATA");
>   if (flags & SECTION_BSS)
>     {
>       fprintf (asm_out_file, ", NOINIT");
>       if (flags & SECTION_LINKONCE)
>         fprintf (asm_out_file, ", COMMON");
>     }
>   else if (flags & SECTION_LINKONCE)
>     fprintf (asm_out_file, ", COMDEF, LINKONCE");
> 
>   putc ('\n', asm_out_file);
> }
> 
> /* This filters out the COMDEF area (section) before calling
>    the "lame default section selector".  */
> 
> static void
> arm_aof_select_section (tree decl, int reloc,
> 		        unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)
> {
>   if (DECL_P (decl) && DECL_COMMON (decl))
>     {
>       comdef_section ();
>       fprintf (asm_out_file, "\tAREA\t|%s|, DATA, COMDEF\n",
>                XSTR (XEXP (DECL_RTL (decl), 0), 0));
>     }
>   else
>     default_select_section (decl, reloc, align);
> }
