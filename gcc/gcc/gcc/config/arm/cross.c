/* Functions for RISC OS as target machine for GNU C compiler.
   Copyright (C) 1997, 1999, 2003, 2004 Free Software Foundation, Inc.
   Contributed by Nick Burrett (nick@sqrt.co.uk)

This file is part of GNU CC.

GNU CC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU CC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU CC; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <errno.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <limits.h>
#include <time.h>
#include <netdb.h>
#include <sys/socket.h>
#include <netinet/in.h>


/* The syslog facilities and priorities.  */
#define PRI_WARNING (1 * 8 + 4)
#define PRI_ERROR   (1 * 8 + 3)

/* Control status of throwback,
   -1 => no throwback possible
    0 => throwback uninitialised,
    1 => throwback initialised
 */
static int arm_throwback_started = 0;

static int arm_throwback_socket = 0;

void arm_throwback_finish (void);

/* Initialise the socket.  */
static void
arm_throwback_start (void)
{
  struct hostent *hp;
  struct servent *servptr;
  struct sockaddr_in name;
  char *hostname;
  int port;

  hostname = getenv("THROWBACK_HOST");
  if (hostname == NULL)
    {
      arm_throwback_started = -1;
      return;
    }

  hp = gethostbyname(hostname);
  if (hp == NULL)
    {
      arm_throwback_started = -1;
      return;
    }

  memset(&name, 0, sizeof(name));
  memcpy(&(name.sin_addr), hp->h_addr, hp->h_length);
  name.sin_family = AF_INET;

  servptr = getservbyname("syslog", "udp");
  if (servptr == NULL)
    port = 514;
  else
    port = servptr->s_port;

  name.sin_port = htons(port);

  arm_throwback_socket = socket(AF_INET, SOCK_DGRAM, 0);
  if (arm_throwback_socket < 0)
    {
      arm_throwback_started = -1;
      return;
    }

  atexit (arm_throwback_finish);
  arm_throwback_started = 1;

  if (connect(arm_throwback_socket, (struct sockaddr *)&name, sizeof(struct sockaddr_in)) < 0)
    {
      arm_throwback_started = -1;
      return;
    }
}


/* Send a syslog message with details of the error.  */
static void
arm_throwback_error (const char *fname, int level,
		     int line_number, const char *error, int errorlen)
{
  char msg[1024];
  int len;
  char hostname[100];
  char timestamp[20];
  time_t timer;
  char pathname[PATH_MAX];

  if (gethostname(hostname, sizeof(hostname)) < 0)
    strcpy(hostname, "unknown");

  time(&timer);
  strftime(timestamp, sizeof(timestamp), "%a %d %H:%M:%S", localtime(&timer));

  if (realpath(fname, pathname) == NULL)
    snprintf(pathname, sizeof(pathname), "%s", fname);

  len = snprintf(msg, sizeof(msg), "<%d>%s %s throwback %s:%d: ", level, timestamp, hostname, pathname, line_number);
  while ((len < sizeof(msg)) && (errorlen > 0))
    {
      if (isprint(*error))
        msg[len++] = *error;
      error++;
      errorlen--;
    }

  if (len > sizeof(msg)) len = sizeof(msg);

  if (send(arm_throwback_socket, msg, len, 0) < 0)
    arm_throwback_started = -1;
}

/* Close the socket.  */
void
arm_throwback_finish (void)
{
  close(arm_throwback_socket);
  arm_throwback_started = 0;
}

/* Throwback interface to GNU family of compilers.  */
void
arm_error_throwback (const char *file, int line, const char *prefix,
		     const char *s)
{
  size_t flen, slen, plen;
  char sline[16];
  int iserr;

  /* If the filename is not specified or "", then return.  */
  if (file == NULL || *file == '\0')
    return;

  /* Initialise throwback.  */
  if (!arm_throwback_started)
    arm_throwback_start ();

/*   printf ("*** throwback: tb=%d, file='%s', line='%d', prefix='%s', s='%s'\n",
          arm_throwback_started, file, line, prefix, s);*/

  flen = strlen (file);
  slen = sprintf (sline, "%d: ", line);
  iserr = prefix == NULL || strcmp (prefix, "warning");
  plen = (iserr) ? sizeof("error: ")-1 : sizeof("warning: ")-1;

  if (arm_throwback_started > 0)
    {
      const char *p;

      /* Errors generated by the C++ compiler and preprocessor can stretch
	 over multiple lines.  DDEUtils uses the newline as a string
	 terminator.  We must call arm_throwback_error() for as many times
	 as there are newlines.  */
      for (p = s; *p != '\0'; /* */)
	{
	  char *msg;

	  /* Skip filename, line and level (warning/error) in the 'p' message:  */
	  if (!strncmp (p, file, flen) && p[flen] == ':')
	    {
	      p += flen + 1; /* Skip filename + ":" */
	      if (!strncmp (p, sline, slen))
	        {
	          p += slen; /* Skip line num + ": " */
	          if (!strncmp (p, (iserr) ? "error: " : "warning: ", plen))
	            p += plen; /* Skip level */
	        }
	    }

	  msg = p;
	  while (*p != '\0' && *p != '\n')
	    p++;
	  if (*p == '\n')
	    p++;

	  arm_throwback_error (file,
			       (!iserr) ? PRI_WARNING : PRI_ERROR,
			       line, msg, p - msg);

	}
    }
}

