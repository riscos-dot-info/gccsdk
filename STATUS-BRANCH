This gccsdk/branches/developers/joty/gcc branch is to develop a GCCSDK based
on gcc4.6trunk together with binutils 2.20.1.  When it is stable enough, it
then can become candidate for merging to gccsdk/trunk/gcc4.

Status patch merging:

- All patches which could be merged more or less straightforwardly, have been
  merged.  The ones which were backport merges were dropped.
  Patches which didn't apply or were in doubt they are still relevant have
  been moved to recipe/patches/gcc/unused.  The further we are with this port,
  it will become clear what their status is (when no longer needed, they will
  be removed).
- recipe/files/gcc/gcc/config/arm/{riscos.c,riscos-elf.h}: the throwback
  support has been disabled (search for 'FIXME') as its implementation needs
  to be partially redone (hopefully in a cleaner way so that parallel building
  works again).  Note gcc now reports columns as well in their warnings/errors
  so this is something we can support in our throwback code as well.
- Currently build breaks with:

--8<--
libtool: compile:  .../gcc4/builddir/cross-gcc/./gcc/xgcc -shared-libgcc -B.../gcc4/builddir/cross-gcc/./gcc -nostdinc++ -L.../gcc4/builddir/cross-gcc/arm-unknown-riscos/scl/fpu/module/libstdc++-v3/src -L.../gcc4/builddir/cross-gcc/arm-unknown-riscos/scl/fpu/module/libstdc++-v3/src/.libs -B.../gcc4/builddir/cross-gcc/arm-unknown-riscos/scl/fpu/module/libunixlib/ -B.../gcc4/builddir/cross-gcc/arm-unknown-riscos/scl/fpu/module/libunixlib/.libs/ -isystem .../gcc4/srcdir/gcc/libunixlib/include -B$GCCSDK_INSTALL_ENV/cross/arm-unknown-riscos/bin/ -B$GCCSDK_INSTALL_ENV/cross/arm-unknown-riscos/lib/ -isystem $GCCSDK_INSTALL_ENV/cross/arm-unknown-riscos/include -isystem $GCCSDK_INSTALL_ENV/cross/arm-unknown-riscos/sys-include -mlibscl -mhard-float -mmodule -I.../gcc4/builddir/cross-gcc/arm-unknown-riscos/scl/fpu/module/libstdc++-v3/include/arm-unknown-riscos -I.../gcc4/builddir/cross-gcc/arm-unknown-riscos/scl/fpu/module/libstdc++-v3/include -I.../gcc4/srcdir/gcc/libstdc++-v3/libsupc++ -I$GCCSDK_INSTALL_ENV/cross/include -fno-implicit-templates -Wall -Wextra -Wwrite-strings -Wcast-qual -fdiagnostics-show-location=once -ffunction-sections -fdata-sections -g -O2 -mlibscl -mhard-float -mmodule -c .../gcc4/srcdir/gcc/libstdc++-v3/src/bitmap_allocator.cc -o bitmap_allocator.o
In file included from .../gcc4/srcdir/gcc/libstdc++-v3/src/bitmap_allocator.cc:26:0:
.../gcc4/builddir/cross-gcc/arm-unknown-riscos/scl/fpu/module/libstdc++-v3/include/ext/bitmap_allocator.h: In member function 'void __gnu_cxx::free_list::_M_insert(std::size_t*)':
.../gcc4/builddir/cross-gcc/arm-unknown-riscos/scl/fpu/module/libstdc++-v3/include/ext/bitmap_allocator.h:639:5: internal compiler error: in legitimize_pic_address, at config/arm/arm.c:5223
Please submit a full bug report,
with preprocessed source if appropriate.
See <http://gccsdk.riscos.info/> for instructions.
--8<--

Status build:

- Enable languages c and c++, multilib configuration with static target libs
  cleanly builds.
- Didn't try any other languages nor shared library configuration.
- The 'riscos' subprojects all build with the made cross-compiler except
  d.so-1.9.9/d-link

Code generation:

- Module code is not correct.  Not all cases of riscos/testsuite/module/ do
  work as expected.
- stack checking vs module is probably not working.

Upstream gcc bug tracking:

- RISC OS target's option crash:
    "ICE in cancel_option()"
    http://gcc.gnu.org/bugzilla/show_bug.cgi?id=31980
  Currently patched by: recipe/patches/gcc/gcc.opts-common.c.p
- Buffer overflow in *push_multi pattern
    http://gcc.gnu.org/bugzilla/show_bug.cgi?id=45029
  Currently patched by one of the hunks in recipe/patches/gcc/gcc.config.arm.arm.md.p

// ---------------------------------------------

Development tracks:

- gdbserver : very promising for remote debugging.  Proof of concept is working.  Implementation is
  a bit temperamental.  Still a lot of implementation is to be done.

- asasm : an ObjAsm clone.  Biggest usecase is RISC OS source code base.
  - Not fully compatible: not going to be easy as asasm is a one pass assembler.  Perhaps we should revise
    that as it would make the implementation of the remaining incompatibilities much more easier.
  - There is a huge catchup to do supporting the recent ARMv6/v7/thumb/NEON/VFP mnemonics.  Perhaps we
    should take a fresh look at this and e.g. convert asasm to a ObjAsm -> GAS source converter and let
    GAS do the actually assembling.

- gcc4.6 + APCS-32 = branch gccsdk/branches/developers/joty/gcc branch with target = arm-unknown-riscos
  - status: see above
  - module support (as we know it) is not finished
  - no NEON/VFP support (unrealistic)

Two projects for AAPCS/EABI target: exact AAPCS flavour is not determined.

- gcc4.6 + target arm-unknown-eabi (or custom AAPCS based one), runtime library libunixlib.
  - embryo state
  - AAPCS support in UnixLib
    - runtime & signal stack is fixed 4 KByte without any checking.  Probably need to move that to a DA.
    - pthread support is broken (is related to the stack creation code).
    - should the ELF loader not be in charge for setting up RISC OS environment handlers ?
    - still some unnecessary fp fiddling.
    - we have no backtrace anymore and need to reimplement this based on the exception unwind data (and you need
      compile with -fexceptions (I think).  Note, can currently only be developed using gcc4.6 (or earlier)
      as llvm-gcc/clang does not yet support zero cost exception handling.
      Probably all our assembler code need exception info added.
    - missing NEON/VFP support for setjmp/longjmp
    - no testing done for NEON/VFP build of UnixLib
  - perhaps a nice multilib configuration ?
  - would possibly useful to compare against llvm/clang but on the long run the feature set should be the same.

- llvm-gcc/clang + target arm-unknown-eabi (or custom AAPCS based one), runtime library libunixlib.
  - prototype is working, resulting binaries can be run under RISC OS.  Very limited tested.
  - currently the build is huge because we're taking llvm-gcc + UnixLib along for just building and using clang.
    In the long run, this could be slimed down.
  - AAPCS support in UnixLib (see gcc4.6 topic)
  - RISC OS native build: very large binaries, not sure if it is going to be realistic to have this running in a 28 MByte wimpslot.

* No answer for module creation when AAPCS/EABI route is taken.  Should we consider to teach our ELF loader to
  load an ELF datablob (which is maded for module use) and install this as a module ? Perhaps it can even make use of shared ELF libraries
  later ?
